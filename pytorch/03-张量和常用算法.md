# Tensor（张量）

在 PyTorch 中，张量（Tensor）是一个 n 维数组，是经常用到的一个数据类型。我们可以这样理解：一维张量等同于向量，二维张量等同于矩阵。张量是一个数据容器，它包含的数据几乎总是数值数据，因此它是数字的容器。机器学习的数据存储在张量中。一般来说，当前所有机器学习系统都使用张量作为基本数据结构。



PyTorch 中最基础的运算单位是张量（Tensor），它支持各种张量运算，如加法、减法、点乘、矩阵乘法等。



* 标量是 0维的张量
* 向量是 1维的张量
* 矩阵是 2维的张量



tensor的类型

| 类型                      | torch                         | tensor               |
| ------------------------- | ----------------------------- | -------------------- |
| 32-bit floating point     | torch.float32 or torch.float  | torch.*.floatTensor  |
| 64-bit floating point     | torch.float64 or torch.double | torch.*.DoubleTensor |
| 16-bit floating point     | torch.float16 or torch.half   | torch.*.HalfTensor   |
| 8-bit integer（unsigned） | torch.uint8                   | torch.*.ByteTensor   |
| 8-bit integer（signed）   | torch.int8                    | torch.*.CharTensor   |
| 16-bit integer（signed）  | torch.int16 or torch.short    | torch.*.ShortTensor  |
| 32-bit integer（signed）  | torch.int32 or torch.int      | torch.*.IntTensor    |
| 64-bit integer（signed）  | torch.int64 or torch.long     | torch.*.LongTensor   |
| Boolean                   | torch.bool                    | torch.*.BoolTensor   |



# tensor的创建

| 函数                               | 功能                      |
| ---------------------------------- | ------------------------- |
| Tensor(*size)                      | 基础构造函数              |
| Tensor(data)                       | 类似np.array              |
| ones(*size)                        | 全1Tensor                 |
| zeros(*size)                       | 全0Tensor                 |
| eye(*size)                         | 对角线为1，其他为0        |
| arange(s,e,step)                   | 从s到e，步长为step        |
| linspace(s,e,steps)                | 从s到e，均匀切分成steps份 |
| rand/randn(*size)                  | 均匀/标准分布             |
| normal(mean,std)/uniform_(from,to) | 正态分布/均匀分布         |
| randperm(m)                        | 随机排列                  |

`type_as`函数的作用是将输入张量的数据类型转换为与指定的张量相同的数据类型。它通常用于数据类型转换，以确保计算操作中涉及的张量具有相同的数据类型，从而避免数据类型不匹配的错误。



代码参考：pytorch-code/00_algorithm/00_tensor_create

0)

```python
import torch
a = torch.Tensor([[1, 2],[3, 4]])
print(a)
```

```
tensor([[1., 2.],
        [3., 4.]])
```

1)

```python
import torch

b = torch.Tensor(2, 2)
print(b)
```

```
tensor([[0., 0.],
        [0., 0.]])
```

2)

```python
import torch

a = torch.Tensor([[1, 2],[3, 4]])
d = torch.tensor(((1, 2), (3, 4)))
print(d.type())
print(d.type_as(a))
```

```
torch.LongTensor
tensor([[1., 2.],
        [3., 4.]])
```

3)

```python
import torch

a = torch.Tensor([[1, 2],[3, 4]])
d = torch.empty(2,3)
print(d.type())
print(d)
print(d.type_as(a))
```

```
torch.FloatTensor
tensor([[-2.7814e+19,  9.0384e-43,  0.0000e+00],
        [ 0.0000e+00,  0.0000e+00,  0.0000e+00]])
tensor([[-2.7814e+19,  9.0384e-43,  0.0000e+00],
        [ 0.0000e+00,  0.0000e+00,  0.0000e+00]])
```

4)

```python
import torch

a = torch.Tensor([[1, 2],[3, 4]])
d = torch.zeros(2,3)
print(d.type())
print(d)
print(d.type_as(a))
```

```
torch.FloatTensor
tensor([[0., 0., 0.],
        [0., 0., 0.]])
tensor([[0., 0., 0.],
        [0., 0., 0.]])
```

5)

```python
import torch

a = torch.Tensor([[1, 2],[3, 4]])
d = torch.zeros(2,3)
d = torch.zeros_like(d)
print(d.type())
print(d.type_as(a))
```

```
torch.FloatTensor
tensor([[0., 0., 0.],
        [0., 0., 0.]])
```

6)

```python
import torch

a = torch.Tensor([[1, 2],[3, 4]])
d = torch.eye(2, 2)
print(d.type())
print(d.type_as(a))
```

```
torch.FloatTensor
tensor([[1., 0.],
        [0., 1.]])
```

7)

```python
import torch

a = torch.Tensor([[1, 2],[3, 4]])
d = torch.ones(2, 2)
print(d.type())
print(d.type_as(a))
```

```
torch.FloatTensor
tensor([[1., 1.],
        [1., 1.]])
```

8)

```python
import torch

a = torch.Tensor([[1, 2],[3, 4]])
d = torch.ones(2, 2)
d = torch.ones_like(d)
print(d.type())
print(d.type_as(a))
```

```
torch.FloatTensor
tensor([[1., 1.],
        [1., 1.]])
```

9)

```python
import torch

a = torch.Tensor([[1, 2],[3, 4]])
d = torch.rand(2, 3)
print(d.type())
print(d.type_as(a))
```

```
torch.FloatTensor
tensor([[0.5807, 0.6620, 0.8287],
        [0.1298, 0.7195, 0.0849]])
```

10)

```python
import torch

a = torch.Tensor([[1, 2],[3, 4]])
d = torch.arange(2, 10, 2)
print(d.type())
print(d.type_as(a))
```

```
torch.LongTensor
tensor([2., 4., 6., 8.])
```

11)

```python
import torch

a = torch.Tensor([[1, 2],[3, 4]])
d = torch.linspace(10, 2, 3)
print(d.type())
print(d.type_as(a))
```

```
torch.FloatTensor
tensor([10.,  6.,  2.])
```

12）

```python
import torch

b = torch.Tensor(2, 2)
dd = torch.normal(mean=0, std=1, size=(2, 3), out=b)
print(b)
print(dd)
```

```
tensor([[ 1.4357,  0.9427, -0.8694],
        [ 1.0122, -0.7856, -2.4967]])
tensor([[ 1.4357,  0.9427, -0.8694],
        [ 1.0122, -0.7856, -2.4967]])
```

13)

```python
import torch

a = torch.Tensor([[1, 2],[3, 4]])
d = torch.normal(mean=torch.rand(5), std=torch.rand(5))
print(d.type())
print(d.type_as(a))

```

```
torch.FloatTensor
tensor([0.2504, 1.7975, 0.3099, 0.3428, 0.2408])
```

14)

```python
import torch

a = torch.Tensor([[1, 2],[3, 4]])
d = torch.Tensor(2, 2).uniform_(-1, 1)
print(d.type())
print(d.type_as(a))
```

```
torch.FloatTensor
tensor([[ 0.7297,  0.5313],
        [-0.9879, -0.1133]])
```

15)

```python
import torch

a = torch.Tensor([[1, 2],[3, 4]])
d = torch.randperm(10)
print(d.type())
print(d.type_as(a))

```

```
torch.LongTensor
tensor([5., 4., 7., 9., 3., 6., 0., 1., 2., 8.])
```



# tensor的属性

1. **dtype**：这是torch一个类，torch提供了12种数据类型类，例如torch.float32、torch.float64、torch.int32等。dtype属性标识了torch.Tensor的数据类型。

2. **shape**：这是一个描述张量形状的元组，表示张量的维度。例如，一个2x3的张量，其shape属性为(2, 3)。

3. **device**：这是torch中一个类，说明Tensor存储的位置。Tensor默认存在cpu中。每个设备名称都是特定的设备编号，如'cpu'或'cuda:X'（其中X是函数torch.cuda.current_device()的返回值）。

4. **layout**：这是torch中一个类，标识了torch.Tensor在内存中的布局模式。现在支持的内存布局模式有torch.strided和torch.sparse_coo。前者表示跨步存储代表了密集张量的存储布局方式，后者表示稀疏矩阵存储方式。

   * 稀疏的张量, torch.sparse_coo_tensor

   * coo类型表示了非0元素的坐标形式

     ```python
     indices = torch.tensor([[0,1,1], [2,0,2]])
     values = torch.tensor([3,4,5], dtype=torch.float32)
     x = torch.sparse_coo_tensor(i, v, [2,4])
     ```

   * 稀疏张量的作用: 主要优点在于它 `只存储非零元素的位置和值，而不需要为零元素分配存储空间`。这样，对于包含大量零值元素的数据，稀疏张量可以大大减少内存占用。此外，稀疏张量的计算操作也只针对非零元素进行，从而提高了计算效率。

1)

```python
import torch

# 创建一个张量
x = torch.tensor([1, 2, 3, 4, 5])

# 获取张量的属性
print(x.shape)  # 输出：torch.Size([5])
print(x.dtype)  # 输出：torch.int32
print(x.device)  # 输出：cpu
print(x.is_sparse)  # 输出：False

# 修改张量的属性
x = x.to(device='cuda')  # 将张量移动到GPU上
print(x.device)  # 输出：cuda:0

x = x.float()  # 将张量的数据类型转换为float32
print(x.dtype)  # 输出：torch.float32
```



2)

创建一个tensor,存储的设备是 cuda，默认是cpu

```python
import torch

dev = torch.device("cuda")
a = torch.tensor([2, 2],
                 dtype=torch.float32,
                 device=dev)
print(a)
```

```
tensor([2., 2.], device='cuda:0')
```



3) 稀疏张量

```python
import torch

dev = torch.device("cuda")
i = torch.tensor([[0, 1, 2], [0, 1, 2]])
v = torch.tensor([1, 2, 3])
a = torch.sparse_coo_tensor(i, v, (4, 4),
                            dtype=torch.float32,
                            device=dev).to_dense()
print(a)
```

```
tensor([[1., 0., 0., 0.],
        [0., 2., 0., 0.],
        [0., 0., 3., 0.],
        [0., 0., 0., 0.]], device='cuda:0')
```

```
i = torch.tensor([[0, 1, 2], [0, 1, 2]])
v = torch.tensor([1, 2, 3])

0,0位置是1，1,1位置是2，2,2位置是3.其他位置为0
```





# 点乘

张量的点乘（element-wise multiplication）是指逐元素相乘的操作。它接受两个或多个张量作为输入，并按元素方式将它们相乘。点乘操作使用 `torch.mul()` 函数或 `*` 运算符进行计算。

```python
import torch  
  
# 创建两个张量  
tensor1 = torch.tensor([1, 2, 3])  
tensor2 = torch.tensor([4, 5, 6])  
  
# 使用点乘操作将它们相乘  
result = tensor1.mul(tensor2)  
  
print(result)
```

输出

```python
tensor([ 4, 10, 18])
```

在上面的示例中，`tensor1` 和 `tensor2` 是两个一维张量。使用 `mul()` 函数和 `*` 运算符可以对它们执行点乘操作。结果是一个新的一维张量，其中每个元素都是 `tensor1` 和 `tensor2` 中对应元素的乘积。



# 矩阵乘法







